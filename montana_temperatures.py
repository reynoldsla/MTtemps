# -*- coding: utf-8 -*-
"""Montana Temperatures

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1diPDuicNPjwspBkQ2inuW1vd1HPjtvqO

##Displaying January and July temperature data for Montana, United States

Authors : Lyra Reynolds

## The data
There are two datasets from the Montana Climate Office.  

`MT_monthly_temp.csv` has the monthly mean for all pf the stations across the state by month.

`MT_station_meta.csv` provides more information on each station, as well as the lat and lon of each station.

## Calculations and displays in this Notebook

1. The skew, kurtosis, mean, and median, standard deviation of the mean min and max temperatures by station.
2. The skew, kurtosis, mean, and median, standard deviation of the mean min and max temperatures by year.
3. Two histograms of min and mean temperatures.
4. For all of the data calculate the statistical probability that the min temperature will be below zero (C). Show the histograms that represent this visually. See figures 6.3 and 6.4 for examples.
5. For all of the data calculate the statistical probability that the max temperature will be below zero (C). Show the histograms that represent this visually. See figures 6.3 and 6.4 for examples.
6. Two maps in the same frame (2 subplots). 
- One should have January mean temperature for  for each station.
- The second map should have A map with of July mean monthly temperature for July for each station.
- Temperatures should be represented by an intuitive color scheme.
- The map should have an outline of Montana.
- Bonus points if you have a backgound map.
7. The geographic center of these weather stations should also be represented and labeled on the maps.


*This notebook was part of a midterm assessment for GPHY 484 course at Montana State University. Though this project was assigned, all code was written by the notebook's authors*

# Import Libraries & files
"""

#install, import, and load libraries
import pandas as pd #import will import & load the library
!pip install geopandas -q  #q will remove the noise from the install
import geopandas as gpd
import seaborn as sns
!pip install contextily -q #install will install the library for import
import contextily as ctx
import xyzservices.providers as xyz
import matplotlib as mpl
import matplotlib.pyplot as plt
!pip install git+https://github.com/pysal/libpysal.git -q
import libpysal as ps
!pip install git+https://github.com/pysal/pointpats.git -q
import pointpats
from pointpats import distance_statistics
from pointpats import PointPattern, PoissonPointProcess, as_window
import numpy as np
import scipy.spatial
!pip install folium -q
import folium
from scipy.stats import norm
from scipy.stats import kurtosis
from scipy.stats import skew
from scipy.stats import variation
from shapely.geometry import Point
import math

# upload CSVs
from google.colab import files
uploaded = files.upload()

"""# Creating, cleaning, and grouping dataframes"""

TempData = pd.read_csv("MT_monthly_temp.csv") #reading the CSV and printing the dataframe
TempData

StationData = pd.read_csv("MT_station_meta.csv") #read CSV and print data frame
StationData

#merge two CSV into one data set, print the merged data frame
merged = pd.merge(TempData, StationData,
                  left_on='station_key', right_on='station')
print(merged)

clean = merged.drop(columns = [ 'date_installed', 'sub_network', 'mesowest_id','gwic_id']) 
#drop individual columns from the merge data frame, makes it look cleaner & name the cleaned up data frame "clean"
clean

#Group data from cleaned data by Year, year is placed as a column rather than index
Year = clean.groupby(['year'],as_index=False).mean()
print(Year)

#turn the group by series into a dataframe that statistics can be calculated on (thank you Stack Overflow!)
ByYear = pd.DataFrame(Year)
ByYear

#Group data from cleaned data frame by station ID, Station is placed as a column rather than an index
Station = clean.groupby(['station_key'],as_index=False).mean()
print(Station)

#turn the group by series into a dataframe that statistics can be calculated on (thank you Stack Overflow!)
ByStation = pd.DataFrame(Station)
ByStation

"""# Calculating statistics & visualize data"""

#find statistics for grouping by Station for min temp (MinS indicates minimum temp by station)
MinSmean = ByStation['mean_min_temp'].mean()
MinSkurtosis = scipy.stats.kurtosis(ByStation["mean_min_temp"])
MinSmedian = np.median(ByStation["mean_min_temp"])
MinSdev = np.std(ByStation['mean_min_temp'])
MinSskew = ByStation['mean_min_temp'].skew()

#place all statistics for the min temp by stations in one data frame (MinS)
data = {'Statistic':['skew', 'kurtosis', 'mean', 'median', 'standard deviation'],
        'Value': [MinSskew, MinSkurtosis, MinSmean, MinSmedian, MinSdev]}
MinS=pd.DataFrame(data)
print(MinS)

#find statistics for grouping by Station for max temp (MaxS indicates maximum temp by station)
MaxSmean = ByStation['mean_max_temp'].mean()
MaxSkurtosis = scipy.stats.kurtosis(ByStation["mean_max_temp"])
MaxSmedian = np.median(ByStation["mean_max_temp"])
MaxSdev = np.std(ByStation['mean_max_temp'])
MaxSskew = ByStation['mean_max_temp'].skew()

#place all statistics for the max temp by stations in one data frame (MaxS)
data = {'Statistic':['skew', 'kurtosis', 'mean', 'median', 'standard deviation'],
        'Value': [MaxSskew, MaxSkurtosis, MaxSmean, MaxSmedian, MaxSdev]}
MaxS=pd.DataFrame(data)
print(MaxS)

#find statistics for grouping by Year for min temp (MinY indicates minimum temp by year)
MinYmean = ByYear['mean_min_temp'].mean()
MinYkurtosis = scipy.stats.kurtosis(ByYear["mean_min_temp"])
MinYmedian = np.median(ByYear["mean_min_temp"])
MinYdev = np.std(ByYear['mean_min_temp'])
MinYskew = ByYear['mean_min_temp'].skew()

#place all statistics for the min temp by year in one data frame (MinY)
data = {'Statistic':['skew', 'kurtosis', 'mean', 'median', 'standard deviation'],
        'Value': [MinYskew, MinYkurtosis, MinYmean, MinYmedian, MinYdev]}
MinY=pd.DataFrame(data)
print(MinY)

#find statistics for grouping by Year for max temp (MaxY indicates maximum temp by year)
MaxYmean = ByYear['mean_max_temp'].mean()
MaxYkurtosis = scipy.stats.kurtosis(ByYear["mean_max_temp"])
MaxYmedian = np.median(ByYear["mean_max_temp"])
MaxYdev = np.std(ByYear['mean_max_temp'])
MaxYskew = ByYear['mean_max_temp'].skew()

#place all statistics for the Max temp by year in one data frame (MaxY)
data = {'Statistic':['skew', 'kurtosis', 'mean', 'median', 'standard deviation'],
        'Value': [MaxYskew, MaxYkurtosis, MaxYmean, MaxYmedian, MaxYdev]}
MaxY=pd.DataFrame(data)
print(MaxY)

#Histogram of the Mean Minimum Temperature 
import matplotlib.pyplot as plt
sns.histplot(data = clean, x = clean["mean_min_temp"], kde = True, stat='density', common_norm=True ) #normalizes data
#density stat normalizes the values so the area in the histogram is 1 - allows
#for normal distribution statistics to be

#Histogram with seaborn with mean plotted as the red line
import matplotlib.pyplot as plt
sns.histplot(data = clean, x = clean["mean_max_temp"], kde = True, stat='density',common_norm=True ) #normalizes data )
#density stat normalizes the values so the area in the histogram is 1 - allows
#for normal distribution statistics to be applies

"""# Statistical likelihoods using z-scores"""

#data is normally distributed, as it appears centered around the mean, has an 
#area under the histogram of 1, and 99% of values are within 3 standard
#deviations of the mean, so we can conduct a standard score test
#setting variable values for the standard score equation to find probability of min temp below zero
xbar = clean['mean_min_temp'].mean() #mean
obs = 0 #observation of 0 degrees
sd = np.std(clean['mean_min_temp']) #std deviation

##Finding the Z-score associated with a minimum temperature of 0, uses equation 6.1 from TextBook
zscoremin = (obs-xbar)/sd #z-score at temp of 0 degrees C
print("the zscore for min temp when temp is zero is", zscoremin)

#set up variable for plotting the zscores of all values to show histogram for probabilities
vals = clean['mean_min_temp'] #assigning all minimum temp data to variable 'vals' 
zscores = (vals - xbar)/sd #calculating the z-scores for all minimum temps
zscoremean = (xbar-xbar)/sd #variable for the z-score of the mean (should be 0)
minzscore = zscores.min() #lowest zscore for the edge of the histogram shading of probability

#plot the Z-scores histogram
f, ax = plt.subplots(1)
plt.hist(zscores, bins = 20)
ax.set_xlabel('Z-Score') #x-axis title
ax.set_ylabel('Count') #y-axis title
plt.axvline(zscoremean, color='r', linestyle='--', label = "Mean") #plot the mean zscore (0)
plt.axvline(zscoremin, color = 'g', linestyle= '-', label = '0 Degrees Celcius') #plot 0 degrees C zscore
ax.axvspan(minzscore, zscoremin, alpha=0.5, color='red') #shows the shaded area of the below 0 temps
plt.show()

"""The z-score of -0.05 corresponds to the probability level of 0.0199 according to the Z-score table here: https://www.mathsisfun.com/data/standard-normal-distribution-table.html
This means that about 2% of the values under the normal curve that are between zero degrees and the mean of the mean minimum temperature from the data sets. When looking for the probability of the temperature below zero, I subtrated 0.0199 from 0.5, as 0.5 is the portion of the curve that lies below the mean. **Therefore, the probability that the mean minimum temperature will be below zero is about 48%.**
"""

#setting variable values for the standard score equation to find probability of max temp below zero
xbarM = clean['mean_max_temp'].mean() #mean
obs = 0 #observation of 0 degress celcius
sdM = np.std(clean['mean_max_temp']) #std deviation

##Finding the Z-score associated with a maximum temperature of 0, uses equation 6.1 from TextBook
zscoreMax = (obs-xbarM)/sdM
print("the zscore for max temp when temp is zero is", zscoreMax)
print(xbarM)

valsMax = clean['mean_max_temp'] #assigning all maximum temp data to variable 'valsMax' 
zscoresMax = (valsMax - xbarM)/sdM #calculating the z-scores for all maximum temps
zscoremeanMax = (xbarM-xbarM)/sdM #variable for the z-score of the mean (should be 0)
minzscoreM = zscoresMax.min() #lowest zscore for the edge of the histogram shading of probability

#plot the Z-scores histogram
f, ax = plt.subplots(1)
plt.hist(zscoresMax, bins = 20)
ax.set_xlabel('Z-Score') #x-axis title
ax.set_ylabel('Count') #y-axis title
plt.axvline(zscoremeanMax, color='r', linestyle='--', label = "Mean") #plot the mean
plt.axvline(zscoreMax, color = 'g', linestyle= '-', label = '0 Degrees Celcius') #plot 0 degrees C
ax.axvspan(minzscoreM, zscoreMax, alpha=0.5, color='red') #shows the shaded area of the below 0 temps 
plt.show()

"""The z-score of -1.217 corresponds to a propability level of 0.3888 from the z-score table. This means that 38.88% of the values are between 0 and the mean mean maximum temperature. To find the probability that the mean maximum temperature will be below zero, I subtracted 0.3888 from 0.5 to get 0.1112. **Therefore, the probability that the mean maximum temperature will be below zero is about 11.12%.**

# Mapping January and July Data
"""

#Adding Montana counties outlines
MT = gpd.read_file('/content/State_of_Montana__Boundary.geojson')
MT = MT.set_crs(epsg = 4326) #coordinate System
MT = MT.to_crs(epsg=3742)
MT.head()
MT.plot()

#Creating GeoDataFrame that is grouped by station and month for mapping
SM = clean.groupby(['station_key', 'month'],as_index=False).mean()
SM = SM.drop(columns = ['year']) #drop year column
#turn the group by series into a dataframe that statistics can be calculated on (thank you Stack Overflow!)
BySM = pd.DataFrame(SM)
BySM
#convert in geodataframe for mapping
gdf = gpd.GeoDataFrame(BySM, geometry=gpd.points_from_xy(BySM.longitude, BySM.latitude))
gdf = gdf.set_crs(epsg=4326)
gdfr = gdf.round(2)

#project data
gdfr = gdfr.to_crs(epsg = 3742)
#creating July temperatures separation
JulyBySM = gdfr.loc[(BySM['month'] == 7)]

#creating January temperatures separation
JanBySM = gdfr.loc[(BySM['month'] == 1)]
JanBySM

print(MT.crs)
print(gdfr.crs)

#Plotting January and July Mean Minimum temps
fig, ax = plt.subplots(1, 2, figsize=(20,10))
cmap = plt.get_cmap('coolwarm')

MT.plot(ax=ax[0], facecolor='none', edgecolor='black', linewidth=1)
#setvariables for later
xs = JulyBySM.geometry.x
ys = JulyBySM.geometry.y

#July Data
sc = ax[0].scatter(JulyBySM.geometry.x, JulyBySM.geometry.y, c=JulyBySM.mean_min_temp, cmap=cmap, s=90)
ax[0].set_title('July Mean Minimum Temperatures', weight = 'bold', size = 14)
ax[0].legend()
cbar_ax = fig.add_axes([0.09, 0.3, 0.01, 0.4])
cb = fig.colorbar(sc, cax=cbar_ax, orientation = 'vertical')
cb.set_label('July Mean Minimum Temps in Degrees C',weight='bold')

ax[0].axis('off')
ctx.add_basemap(
    ax[0], 
    crs=gdfr.crs)

#January Data
MT.plot(ax=ax[1], facecolor='none', edgecolor='black', linewidth=1)
xs1 = JanBySM.geometry.x
ys1 = JanBySM.geometry.y

sc2 = ax[1].scatter(JanBySM.geometry.x, JanBySM.geometry.y, c=JanBySM.mean_min_temp, s=90, cmap=cmap)
ax[1].set_title('January Mean Minimum Temperatures', weight = 'bold', size = 14)
cbar_ax2 = fig.add_axes([0.5, 0.3, 0.01, 0.4])
cb2 = fig.colorbar(sc2, cax=cbar_ax2, orientation = 'vertical')
cb2.set_label('January Mean Minimum Temps in Degrees C',weight='bold')

ax[1].axis('off')
ctx.add_basemap(
    ax[1], 
    crs=gdfr.crs)

#Plotting January and July Mean Maximum temps
fig, ax = plt.subplots(1, 2, figsize=(25,10))
cmap = plt.get_cmap('coolwarm')

MT.plot(ax=ax[0], facecolor='none', edgecolor='black', linewidth=1)
#setvariables for later
xs = JulyBySM.geometry.x
ys = JulyBySM.geometry.y

#July Data
sc = ax[0].scatter(JulyBySM.geometry.x, JulyBySM.geometry.y, c=JulyBySM.mean_max_temp, cmap=cmap, s=90)
ax[0].set_title('July Mean Maximum Temperatures', weight = 'bold', size = 14)
ax[0].legend()
cbar_ax = fig.add_axes([0.09, 0.3, 0.01, 0.4])
cb = fig.colorbar(sc, cax=cbar_ax, orientation = 'vertical')
cb.set_label('July Mean Maximum Temps in Degrees C',weight='bold')

ax[0].axis('off')
ctx.add_basemap(ax[0], crs=gdfr.crs)
#January Data
MT.plot(ax=ax[1], facecolor='none', edgecolor='black', linewidth=1)
xs1 = JanBySM.geometry.x
ys1 = JanBySM.geometry.y

sc2 = ax[1].scatter(JanBySM.geometry.x, JanBySM.geometry.y, c=JanBySM.mean_max_temp, s=90, cmap=cmap)
ax[1].set_title('January Mean Maximum Temperatures', weight = 'bold', size = 14)
ax[1].axis('off')
cbar_ax2 = fig.add_axes([0.5, 0.3, 0.01, 0.4])
cb2 = fig.colorbar(sc2, cax=cbar_ax2, orientation = 'vertical')
cb2.set_label('January Mean Maximum Temps in Degrees C',weight='bold')

ax[1].axis('off')
ctx.add_basemap(ax[1], crs=gdfr.crs)

"""#Plotting Geographic Mean of weather stations on Temperature Data"""

# Calculate mean
# First create a dataframe
centroid = gdfr[['latitude', 'longitude']]
centroid["lat_rad"] = gdfr["latitude"] * math.pi/180 #Compute lat and lon in radians and save to new df
centroid["lon_rad"] = gdfr["longitude"] *math.pi/180

# Now transpose onto the XYZ spheroid
centroid['X'] = np.cos(centroid.lat_rad)*np.cos(centroid.lon_rad) 
centroid['Y'] = np.cos(centroid.lat_rad)*np.sin(centroid.lon_rad)
centroid['Z'] = np.sin(centroid.lat_rad)

centroid.head()

#reateing location mean for the geographic center
centroid = np.mean(centroid)
centroid.head()

#Put lat and long into x-y
PI = 3.14

centroid['meanLon'] = (np.arctan2(centroid.Y, centroid.X))*180/PI

centroid['hyp'] = np.sqrt(centroid.X * centroid.X + centroid.Y * centroid.Y)
centroid['meanLat'] = (np.arctan2(centroid.Z, centroid.hyp))*180/PI
centroid.head() ## Note this is a numpy array -> clean up and change to pandas dataframe.

centroid = centroid[['meanLat','meanLon']] # only use the lat/lon
centroid = pd.DataFrame(centroid) # convert to a df
centroid = centroid.transpose() # get it lined up properly
centroid # make sure that it worked

xyCenter = gpd.GeoDataFrame(centroid, geometry=gpd.points_from_xy(centroid.meanLon, centroid.meanLat))
xyCenter

#Create new geodataframe for center point and project it--same steps as above

xyCenter = xyCenter.set_crs(epsg = 4326) #WGS 84
xyCenter = xyCenter.to_crs(epsg = 3742) #UTM 12N
#Add columns"
xyCenter["x"] = xyCenter.geometry.x
xyCenter["y"] = xyCenter.geometry.y
#Remove colunms
xyCenter = xyCenter.drop(columns=['meanLat', 'meanLon'])
xyCenter.head()

#Plotting January and July Mean Minimum temps
fig, ax = plt.subplots(1, 2, figsize=(20,10))
cmap = plt.get_cmap('seismic')

MT.plot(ax=ax[0], facecolor='none', edgecolor='black', linewidth=1)
#setvariables for later
xs = JulyBySM.geometry.x
ys = JulyBySM.geometry.y

xyCenter.plot(ax=ax[0], marker='*',color="black", markersize=500, label='Station Centroid',legend=True)


#July Data
sc = ax[0].scatter(JulyBySM.geometry.x, JulyBySM.geometry.y, c=JulyBySM.mean_min_temp, cmap=cmap, s=90)
ax[0].set_title('July Mean Minimum Temperatures', weight = 'bold', size = 14)
ax[0].legend()
cbar_ax = fig.add_axes([0.09, 0.3, 0.01, 0.4])
cb = fig.colorbar(sc, cax=cbar_ax, orientation = 'vertical')
cb.set_label('July Mean Minimum Temps in Degrees C',weight='bold')

ax[0].axis('off')
ctx.add_basemap(
    ax[0], 
    crs=gdfr.crs)

#January Data
MT.plot(ax=ax[1], facecolor='none', edgecolor='black', linewidth=1)
xs1 = JanBySM.geometry.x
ys1 = JanBySM.geometry.y

xyCenter.plot(ax=ax[1], marker='*',color="black", markersize=500, label='Station Centroid',legend=True)


sc2 = ax[1].scatter(JanBySM.geometry.x, JanBySM.geometry.y, c=JanBySM.mean_min_temp, s=90, cmap=cmap)
ax[1].set_title('January Mean Minimum Temperatures', weight = 'bold', size = 14)
cbar_ax2 = fig.add_axes([0.5, 0.3, 0.01, 0.4])
cb2 = fig.colorbar(sc2, cax=cbar_ax2, orientation = 'vertical')
cb2.set_label('January Mean Minimum Temps in Degrees C',weight='bold')

ax[1].axis('off')
ctx.add_basemap(
    ax[1], 
    crs=gdfr.crs)

#Plotting January and July Mean Maximum temps WITH GEOGRAPHIC CENTER
fig, ax = plt.subplots(1, 2, figsize=(25,10))
cmap = plt.get_cmap('seismic')

MT.plot(ax=ax[0], facecolor='none', edgecolor='black', linewidth=1)
#setvariables for later
xs = JulyBySM.geometry.x
ys = JulyBySM.geometry.y

xyCenter.plot(ax=ax[0], marker='*',color="black", markersize=500, label='Station Centroid',legend=True)

#July Data
sc = ax[0].scatter(JulyBySM.geometry.x, JulyBySM.geometry.y, c=JulyBySM.mean_max_temp, cmap=cmap, s=90)
ax[0].set_title('July Mean Maximum Temperatures', weight = 'bold', size = 14)
ax[0].legend()
cbar_ax = fig.add_axes([0.09, 0.3, 0.01, 0.4])
cb = fig.colorbar(sc, cax=cbar_ax, orientation = 'vertical')
cb.set_label('July Mean Maximum Temps in Degrees C',weight='bold')

ax[0].axis('off')
ctx.add_basemap(ax[0], crs=gdfr.crs)
#January Data
MT.plot(ax=ax[1], facecolor='none', edgecolor='black', linewidth=1)
xs1 = JanBySM.geometry.x
ys1 = JanBySM.geometry.y

xyCenter.plot(ax=ax[1], marker='*',color="black", markersize=500, label='Station Centroid',legend=True)

sc2 = ax[1].scatter(JanBySM.geometry.x, JanBySM.geometry.y, c=JanBySM.mean_max_temp, s=90, cmap=cmap)
ax[1].set_title('January Mean Maximum Temperatures', weight = 'bold', size = 14)
ax[1].axis('off')
cbar_ax2 = fig.add_axes([0.5, 0.3, 0.01, 0.4])
cb2 = fig.colorbar(sc2, cax=cbar_ax2, orientation = 'vertical')
cb2.set_label('January Mean Maximum Temps in Degrees C',weight='bold')

ax[1].axis('off')
ctx.add_basemap(ax[1], crs=gdfr.crs)

